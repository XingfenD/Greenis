/**
 * @file ./inc/conn.h
 * @brief Defines the Conn class for managing network connection states and data transmission.
 *
 * @author Fendy (xingfen.star@gmail.com)
 * @version 1.0
 * @date 2025-03-13
 * @copyright Copyright (c) 2025
 *
 * @details The Conn class encapsulates a file descriptor, read/write status, and input/output buffers. It provides methods to handle new connection acceptance, reading from and writing to sockets, and closing connections. This class simplifies the complexity of responding to network events by providing a high-level interface over low-level socket operations, making it easier to develop network applications. Key functionalities include:
 * - Accepting new connections via the `handle_accept` method.
 * - Processing incoming data through the `try_one_request` method.
 * - Writing response data with the `handle_write` method.
 * - Reading data from the client using the `handle_read` method.
 * - Managing internal states such as whether to read (`want_read`), write (`want_write`), or close (`want_close`) the connection.
 *
 * The class also disables copy constructor and assignment operator to ensure proper resource management, while supporting move semantics for efficient transfer of resources.
 */

#ifndef CONN_H
#define CONN_H

    #include <vector>


    /* the origin struct Conn */
    /*
    struct Conn {
        int fd = -1;
        // application's intention, for the event loop
        bool want_read = false;
        bool want_write = false;
        bool want_close = false;
        // buffered input and output
        std::vector<uint8_t> incoming;  // data to be parsed by the application
        std::vector<uint8_t> outgoing;  // responses generated by the application
    };

    static void buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len);
    static void buf_consume(std::vector<uint8_t> &buf, size_t n);

    static Conn *handle_accept(int fd);
    static bool try_one_request(Conn *conn);
    static void handle_write(Conn *conn);
    static void handle_read(Conn *conn);
    */

    class Conn {
        public:
            Conn();
            ~Conn();

            /* Disable copy constructor and assignment operator */
            Conn(const Conn&) = delete;
            Conn& operator=(const Conn&) = delete;

            /* Move constructor and move assignment operator */
            Conn(Conn&& other) noexcept;
            Conn& operator=(Conn&& other) noexcept;

            /* Application callback: when the listening socket is ready */
            static Conn* handle_accept(int listen_fd);

            /* Process one request if there is enough data */
            bool try_one_request();

            /* Application callback: when the socket is writable */
            void handle_write();

            /* Application callback: when the socket is readable */
            void handle_read();

        private:
            int fd; /* File descriptor */
            bool want_read; /* Whether to read data */
            bool want_write; /* Whether to write data */
            bool want_close; /* Whether to close the connection */
            std::vector<uint8_t> incoming; /* Unprocessed data read from the client */
            std::vector<uint8_t> outgoing; /* Response data to be sent to the client */
    };

#endif /* CONN_H */
